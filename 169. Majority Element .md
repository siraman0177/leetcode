# brute force approach 

class Solution {
public:
    int majorityElement(vector<int>& nums) {
       int n=nums.size();

        for (int val:nums){
            int flag =0;
            for(int vall:nums){
                if(vall==val){
                flag++;}
            }
        if(flag>n/2){
        return val ;}
        }
    return -1;
    }
};

# In brute froce approach we just counted the frequency and return the value 

# most optimized approach  by moore's vomiting algorithm 

class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n= nums.size();
        int freq=0 ,ans=0;
        for (int i=0;i<n;i++){
            if(freq==0)
            ans=nums[i];
            if(ans==nums[i]) freq++;
            else freq--;
        }
    return ans;
    }
};

# acc. to moore's algo. the power of the majority element will always be greater than the other elements power all combined because it occupies more than n/2 element space in an array .
# it says travse the array , assume 1st element is the majority element then we traverse and see if the next element is same or not , if same then freq++ else freq -- then return ans

